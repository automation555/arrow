// @generated by protobuf-ts 2.2.2 with parameter server_grpc1,client_grpc1
// @generated from protobuf file "FlightSql.proto" (package "arrow.flight.protocol.sql", syntax proto3)
// tslint:disable
//
//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
// <p>
// http://www.apache.org/licenses/LICENSE-2.0
// <p>
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 *
 * Represents a metadata request. Used in the command member of FlightDescriptor
 * for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  info_name: uint32 not null,
 *  value: dense_union<
 *              string_value: utf8,
 *              bool_value: bool,
 *              bigint_value: int64,
 *              int32_bitmask: int32,
 *              string_list: list<string_data: utf8>
 *              int32_to_int32_list_map: map<key: int32, value: list<$data$: int32>>
 * >
 * where there is one row per requested piece of metadata information.
 *
 * @generated from protobuf message arrow.flight.protocol.sql.CommandGetSqlInfo
 */
export interface CommandGetSqlInfo {
    /**
     *
     * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide
     * Flight SQL clients with basic, SQL syntax and SQL functions related information.
     * More information types can be added in future releases.
     * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.
     *
     * Note that the set of metadata may expand.
     *
     * Initially, Flight SQL will support the following information types:
     * - Server Information - Range [0-500)
     * - Syntax Information - Range [500-1000)
     * Range [0-10,000) is reserved for defaults (see SqlInfo enum for default options).
     * Custom options should start at 10,000.
     *
     * If omitted, then all metadata will be retrieved.
     * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must
     * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved for future use.
     * If additional metadata is included, the metadata IDs should start from 10,000.
     *
     * @generated from protobuf field: repeated uint32 info = 1;
     */
    info: number[];
}
/**
 *
 * Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.
 * The definition of a catalog depends on vendor/implementation. It is usually the database itself
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  catalog_name: utf8 not null
 * >
 * The returned data should be ordered by catalog_name.
 *
 * @generated from protobuf message arrow.flight.protocol.sql.CommandGetCatalogs
 */
export interface CommandGetCatalogs {
}
/**
 *
 * Represents a request to retrieve the list of database schemas on a Flight SQL enabled backend.
 * The definition of a database schema depends on vendor/implementation. It is usually a collection of tables.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  catalog_name: utf8,
 *  db_schema_name: utf8 not null
 * >
 * The returned data should be ordered by catalog_name, then db_schema_name.
 *
 * @generated from protobuf message arrow.flight.protocol.sql.CommandGetDbSchemas
 */
export interface CommandGetDbSchemas {
    /**
     *
     * Specifies the Catalog to search for the tables.
     * An empty string retrieves those without a catalog.
     * If omitted the catalog name should not be used to narrow the search.
     *
     * @generated from protobuf field: optional string catalog = 1;
     */
    catalog?: string;
    /**
     *
     * Specifies a filter pattern for schemas to search for.
     * When no db_schema_filter_pattern is provided, the pattern will not be used to narrow the search.
     * In the pattern string, two special characters can be used to denote matching rules:
     *    - "%" means to match any substring with 0 or more characters.
     *    - "_" means to match any one character.
     *
     * @generated from protobuf field: optional string db_schema_filter_pattern = 2;
     */
    dbSchemaFilterPattern?: string;
}
/**
 *
 * Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  catalog_name: utf8,
 *  db_schema_name: utf8,
 *  table_name: utf8 not null,
 *  table_type: utf8 not null,
 *  [optional] table_schema: bytes not null (schema of the table as described in Schema.fbs::Schema,
 *                                           it is serialized as an IPC message.)
 * >
 * The returned data should be ordered by catalog_name, db_schema_name, table_name, then table_type, followed by table_schema if requested.
 *
 * @generated from protobuf message arrow.flight.protocol.sql.CommandGetTables
 */
export interface CommandGetTables {
    /**
     *
     * Specifies the Catalog to search for the tables.
     * An empty string retrieves those without a catalog.
     * If omitted the catalog name should not be used to narrow the search.
     *
     * @generated from protobuf field: optional string catalog = 1;
     */
    catalog?: string;
    /**
     *
     * Specifies a filter pattern for schemas to search for.
     * When no db_schema_filter_pattern is provided, all schemas matching other filters are searched.
     * In the pattern string, two special characters can be used to denote matching rules:
     *    - "%" means to match any substring with 0 or more characters.
     *    - "_" means to match any one character.
     *
     * @generated from protobuf field: optional string db_schema_filter_pattern = 2;
     */
    dbSchemaFilterPattern?: string;
    /**
     *
     * Specifies a filter pattern for tables to search for.
     * When no table_name_filter_pattern is provided, all tables matching other filters are searched.
     * In the pattern string, two special characters can be used to denote matching rules:
     *    - "%" means to match any substring with 0 or more characters.
     *    - "_" means to match any one character.
     *
     * @generated from protobuf field: optional string table_name_filter_pattern = 3;
     */
    tableNameFilterPattern?: string;
    /**
     *
     * Specifies a filter of table types which must match.
     * The table types depend on vendor/implementation. It is usually used to separate tables from views or system tables.
     * TABLE, VIEW, and SYSTEM TABLE are commonly supported.
     *
     * @generated from protobuf field: repeated string table_types = 4;
     */
    tableTypes: string[];
    /**
     * Specifies if the Arrow schema should be returned for found tables.
     *
     * @generated from protobuf field: bool include_schema = 5;
     */
    includeSchema: boolean;
}
/**
 *
 * Represents a request to retrieve the list of table types on a Flight SQL enabled backend.
 * The table types depend on vendor/implementation. It is usually used to separate tables from views or system tables.
 * TABLE, VIEW, and SYSTEM TABLE are commonly supported.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  table_type: utf8 not null
 * >
 * The returned data should be ordered by table_type.
 *
 * @generated from protobuf message arrow.flight.protocol.sql.CommandGetTableTypes
 */
export interface CommandGetTableTypes {
}
/**
 *
 * Represents a request to retrieve the primary keys of a table on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  catalog_name: utf8,
 *  db_schema_name: utf8,
 *  table_name: utf8 not null,
 *  column_name: utf8 not null,
 *  key_name: utf8,
 *  key_sequence: int not null
 * >
 * The returned data should be ordered by catalog_name, db_schema_name, table_name, key_name, then key_sequence.
 *
 * @generated from protobuf message arrow.flight.protocol.sql.CommandGetPrimaryKeys
 */
export interface CommandGetPrimaryKeys {
    /**
     *
     * Specifies the catalog to search for the table.
     * An empty string retrieves those without a catalog.
     * If omitted the catalog name should not be used to narrow the search.
     *
     * @generated from protobuf field: optional string catalog = 1;
     */
    catalog?: string;
    /**
     *
     * Specifies the schema to search for the table.
     * An empty string retrieves those without a schema.
     * If omitted the schema name should not be used to narrow the search.
     *
     * @generated from protobuf field: optional string db_schema = 2;
     */
    dbSchema?: string;
    /**
     * Specifies the table to get the primary keys for.
     *
     * @generated from protobuf field: string table = 3;
     */
    table: string;
}
/**
 *
 * Represents a request to retrieve a description of the foreign key columns that reference the given table's
 * primary key columns (the foreign keys exported by a table) of a table on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  pk_catalog_name: utf8,
 *  pk_db_schema_name: utf8,
 *  pk_table_name: utf8 not null,
 *  pk_column_name: utf8 not null,
 *  fk_catalog_name: utf8,
 *  fk_db_schema_name: utf8,
 *  fk_table_name: utf8 not null,
 *  fk_column_name: utf8 not null,
 *  key_sequence: int not null,
 *  fk_key_name: utf8,
 *  pk_key_name: utf8,
 *  update_rule: uint1 not null,
 *  delete_rule: uint1 not null
 * >
 * The returned data should be ordered by fk_catalog_name, fk_db_schema_name, fk_table_name, fk_key_name, then key_sequence.
 * update_rule and delete_rule returns a byte that is equivalent to actions declared on UpdateDeleteRules enum.
 *
 * @generated from protobuf message arrow.flight.protocol.sql.CommandGetExportedKeys
 */
export interface CommandGetExportedKeys {
    /**
     *
     * Specifies the catalog to search for the foreign key table.
     * An empty string retrieves those without a catalog.
     * If omitted the catalog name should not be used to narrow the search.
     *
     * @generated from protobuf field: optional string catalog = 1;
     */
    catalog?: string;
    /**
     *
     * Specifies the schema to search for the foreign key table.
     * An empty string retrieves those without a schema.
     * If omitted the schema name should not be used to narrow the search.
     *
     * @generated from protobuf field: optional string db_schema = 2;
     */
    dbSchema?: string;
    /**
     * Specifies the foreign key table to get the foreign keys for.
     *
     * @generated from protobuf field: string table = 3;
     */
    table: string;
}
/**
 *
 * Represents a request to retrieve the foreign keys of a table on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  pk_catalog_name: utf8,
 *  pk_db_schema_name: utf8,
 *  pk_table_name: utf8 not null,
 *  pk_column_name: utf8 not null,
 *  fk_catalog_name: utf8,
 *  fk_db_schema_name: utf8,
 *  fk_table_name: utf8 not null,
 *  fk_column_name: utf8 not null,
 *  key_sequence: int not null,
 *  fk_key_name: utf8,
 *  pk_key_name: utf8,
 *  update_rule: uint1 not null,
 *  delete_rule: uint1 not null
 * >
 * The returned data should be ordered by pk_catalog_name, pk_db_schema_name, pk_table_name, pk_key_name, then key_sequence.
 * update_rule and delete_rule returns a byte that is equivalent to actions:
 *    - 0 = CASCADE
 *    - 1 = RESTRICT
 *    - 2 = SET NULL
 *    - 3 = NO ACTION
 *    - 4 = SET DEFAULT
 *
 * @generated from protobuf message arrow.flight.protocol.sql.CommandGetImportedKeys
 */
export interface CommandGetImportedKeys {
    /**
     *
     * Specifies the catalog to search for the primary key table.
     * An empty string retrieves those without a catalog.
     * If omitted the catalog name should not be used to narrow the search.
     *
     * @generated from protobuf field: optional string catalog = 1;
     */
    catalog?: string;
    /**
     *
     * Specifies the schema to search for the primary key table.
     * An empty string retrieves those without a schema.
     * If omitted the schema name should not be used to narrow the search.
     *
     * @generated from protobuf field: optional string db_schema = 2;
     */
    dbSchema?: string;
    /**
     * Specifies the primary key table to get the foreign keys for.
     *
     * @generated from protobuf field: string table = 3;
     */
    table: string;
}
/**
 *
 * Represents a request to retrieve a description of the foreign key columns in the given foreign key table that
 * reference the primary key or the columns representing a unique constraint of the parent table (could be the same
 * or a different table) on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  pk_catalog_name: utf8,
 *  pk_db_schema_name: utf8,
 *  pk_table_name: utf8 not null,
 *  pk_column_name: utf8 not null,
 *  fk_catalog_name: utf8,
 *  fk_db_schema_name: utf8,
 *  fk_table_name: utf8 not null,
 *  fk_column_name: utf8 not null,
 *  key_sequence: int not null,
 *  fk_key_name: utf8,
 *  pk_key_name: utf8,
 *  update_rule: uint1 not null,
 *  delete_rule: uint1 not null
 * >
 * The returned data should be ordered by pk_catalog_name, pk_db_schema_name, pk_table_name, pk_key_name, then key_sequence.
 * update_rule and delete_rule returns a byte that is equivalent to actions:
 *    - 0 = CASCADE
 *    - 1 = RESTRICT
 *    - 2 = SET NULL
 *    - 3 = NO ACTION
 *    - 4 = SET DEFAULT
 *
 * @generated from protobuf message arrow.flight.protocol.sql.CommandGetCrossReference
 */
export interface CommandGetCrossReference {
    /**
     * *
     * The catalog name where the parent table is.
     * An empty string retrieves those without a catalog.
     * If omitted the catalog name should not be used to narrow the search.
     *
     * @generated from protobuf field: optional string pk_catalog = 1;
     */
    pkCatalog?: string;
    /**
     * *
     * The Schema name where the parent table is.
     * An empty string retrieves those without a schema.
     * If omitted the schema name should not be used to narrow the search.
     *
     * @generated from protobuf field: optional string pk_db_schema = 2;
     */
    pkDbSchema?: string;
    /**
     * *
     * The parent table name. It cannot be null.
     *
     * @generated from protobuf field: string pk_table = 3;
     */
    pkTable: string;
    /**
     * *
     * The catalog name where the foreign table is.
     * An empty string retrieves those without a catalog.
     * If omitted the catalog name should not be used to narrow the search.
     *
     * @generated from protobuf field: optional string fk_catalog = 4;
     */
    fkCatalog?: string;
    /**
     * *
     * The schema name where the foreign table is.
     * An empty string retrieves those without a schema.
     * If omitted the schema name should not be used to narrow the search.
     *
     * @generated from protobuf field: optional string fk_db_schema = 5;
     */
    fkDbSchema?: string;
    /**
     * *
     * The foreign table name. It cannot be null.
     *
     * @generated from protobuf field: string fk_table = 6;
     */
    fkTable: string;
}
// SQL Execution Action Messages

/**
 *
 * Request message for the "CreatePreparedStatement" action on a Flight SQL enabled backend.
 *
 * @generated from protobuf message arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest
 */
export interface ActionCreatePreparedStatementRequest {
    /**
     * The valid SQL string to create a prepared statement for.
     *
     * @generated from protobuf field: string query = 1;
     */
    query: string;
}
/**
 *
 * Wrap the result of a "GetPreparedStatement" action.
 *
 * The resultant PreparedStatement can be closed either:
 * - Manually, through the "ClosePreparedStatement" action;
 * - Automatically, by a server timeout.
 *
 * @generated from protobuf message arrow.flight.protocol.sql.ActionCreatePreparedStatementResult
 */
export interface ActionCreatePreparedStatementResult {
    /**
     * Opaque handle for the prepared statement on the server.
     *
     * @generated from protobuf field: bytes prepared_statement_handle = 1;
     */
    preparedStatementHandle: Uint8Array;
    /**
     * If a result set generating query was provided, dataset_schema contains the
     * schema of the dataset as described in Schema.fbs::Schema, it is serialized as an IPC message.
     *
     * @generated from protobuf field: bytes dataset_schema = 2;
     */
    datasetSchema: Uint8Array;
    /**
     * If the query provided contained parameters, parameter_schema contains the
     * schema of the expected parameters as described in Schema.fbs::Schema, it is serialized as an IPC message.
     *
     * @generated from protobuf field: bytes parameter_schema = 3;
     */
    parameterSchema: Uint8Array;
}
/**
 *
 * Request message for the "ClosePreparedStatement" action on a Flight SQL enabled backend.
 * Closes server resources associated with the prepared statement handle.
 *
 * @generated from protobuf message arrow.flight.protocol.sql.ActionClosePreparedStatementRequest
 */
export interface ActionClosePreparedStatementRequest {
    /**
     * Opaque handle for the prepared statement on the server.
     *
     * @generated from protobuf field: bytes prepared_statement_handle = 1;
     */
    preparedStatementHandle: Uint8Array;
}
// SQL Execution Messages.

/**
 *
 * Represents a SQL query. Used in the command member of FlightDescriptor
 * for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the query.
 *
 * @generated from protobuf message arrow.flight.protocol.sql.CommandStatementQuery
 */
export interface CommandStatementQuery {
    /**
     * The SQL syntax.
     *
     * @generated from protobuf field: string query = 1;
     */
    query: string;
}
/**
 * *
 * Represents a ticket resulting from GetFlightInfo with a CommandStatementQuery.
 * This should be used only once and treated as an opaque value, that is, clients should not attempt to parse this.
 *
 * @generated from protobuf message arrow.flight.protocol.sql.TicketStatementQuery
 */
export interface TicketStatementQuery {
    /**
     * Unique identifier for the instance of the statement to execute.
     *
     * @generated from protobuf field: bytes statement_handle = 1;
     */
    statementHandle: Uint8Array;
}
/**
 *
 * Represents an instance of executing a prepared statement. Used in the command member of FlightDescriptor for
 * the following RPC calls:
 *  - DoPut: bind parameter values. All of the bound parameter sets will be executed as a single atomic execution.
 *  - GetFlightInfo: execute the prepared statement instance.
 *
 * @generated from protobuf message arrow.flight.protocol.sql.CommandPreparedStatementQuery
 */
export interface CommandPreparedStatementQuery {
    /**
     * Opaque handle for the prepared statement on the server.
     *
     * @generated from protobuf field: bytes prepared_statement_handle = 1;
     */
    preparedStatementHandle: Uint8Array;
}
/**
 *
 * Represents a SQL update query. Used in the command member of FlightDescriptor
 * for the the RPC call DoPut to cause the server to execute the included SQL update.
 *
 * @generated from protobuf message arrow.flight.protocol.sql.CommandStatementUpdate
 */
export interface CommandStatementUpdate {
    /**
     * The SQL syntax.
     *
     * @generated from protobuf field: string query = 1;
     */
    query: string;
}
/**
 *
 * Represents a SQL update query. Used in the command member of FlightDescriptor
 * for the the RPC call DoPut to cause the server to execute the included
 * prepared statement handle as an update.
 *
 * @generated from protobuf message arrow.flight.protocol.sql.CommandPreparedStatementUpdate
 */
export interface CommandPreparedStatementUpdate {
    /**
     * Opaque handle for the prepared statement on the server.
     *
     * @generated from protobuf field: bytes prepared_statement_handle = 1;
     */
    preparedStatementHandle: Uint8Array;
}
/**
 *
 * Returned from the RPC call DoPut when a CommandStatementUpdate
 * CommandPreparedStatementUpdate was in the request, containing
 * results from the update.
 *
 * @generated from protobuf message arrow.flight.protocol.sql.DoPutUpdateResult
 */
export interface DoPutUpdateResult {
    /**
     * The number of records updated. A return value of -1 represents
     * an unknown updated record count.
     *
     * @generated from protobuf field: int64 record_count = 1;
     */
    recordCount: bigint;
}
/**
 * Options for CommandGetSqlInfo.
 *
 * @generated from protobuf enum arrow.flight.protocol.sql.SqlInfo
 */
export enum SqlInfo {
    /**
     * Retrieves a UTF-8 string with the name of the Flight SQL Server.
     *
     * @generated from protobuf enum value: FLIGHT_SQL_SERVER_NAME = 0;
     */
    FLIGHT_SQL_SERVER_NAME = 0,
    /**
     * Retrieves a UTF-8 string with the native version of the Flight SQL Server.
     *
     * @generated from protobuf enum value: FLIGHT_SQL_SERVER_VERSION = 1;
     */
    FLIGHT_SQL_SERVER_VERSION = 1,
    /**
     * Retrieves a UTF-8 string with the Arrow format version of the Flight SQL Server.
     *
     * @generated from protobuf enum value: FLIGHT_SQL_SERVER_ARROW_VERSION = 2;
     */
    FLIGHT_SQL_SERVER_ARROW_VERSION = 2,
    /**
     *
     * Retrieves a boolean value indicating whether the Flight SQL Server is read only.
     *
     * Returns:
     * - false: if read-write
     * - true: if read only
     *
     * @generated from protobuf enum value: FLIGHT_SQL_SERVER_READ_ONLY = 3;
     */
    FLIGHT_SQL_SERVER_READ_ONLY = 3,
    /**
     *
     * Retrieves a boolean value indicating whether the Flight SQL Server supports CREATE and DROP of catalogs.
     *
     * Returns:
     * - false: if it doesn't support CREATE and DROP of catalogs.
     * - true: if it supports CREATE and DROP of catalogs.
     *
     * @generated from protobuf enum value: SQL_DDL_CATALOG = 500;
     */
    SQL_DDL_CATALOG = 500,
    /**
     *
     * Retrieves a boolean value indicating whether the Flight SQL Server supports CREATE and DROP of schemas.
     *
     * Returns:
     * - false: if it doesn't support CREATE and DROP of schemas.
     * - true: if it supports CREATE and DROP of schemas.
     *
     * @generated from protobuf enum value: SQL_DDL_SCHEMA = 501;
     */
    SQL_DDL_SCHEMA = 501,
    /**
     *
     * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.
     *
     * Returns:
     * - false: if it doesn't support CREATE and DROP of tables.
     * - true: if it supports CREATE and DROP of tables.
     *
     * @generated from protobuf enum value: SQL_DDL_TABLE = 502;
     */
    SQL_DDL_TABLE = 502,
    /**
     *
     * Retrieves a uint32 value representing the enu uint32 ordinal for the case sensitivity of catalog, table, schema and table names.
     *
     * The possible values are listed in `arrow.flight.protocol.sql.SqlSupportedCaseSensitivity`.
     *
     * @generated from protobuf enum value: SQL_IDENTIFIER_CASE = 503;
     */
    SQL_IDENTIFIER_CASE = 503,
    /**
     * Retrieves a UTF-8 string with the supported character(s) used to surround a delimited identifier.
     *
     * @generated from protobuf enum value: SQL_IDENTIFIER_QUOTE_CHAR = 504;
     */
    SQL_IDENTIFIER_QUOTE_CHAR = 504,
    /**
     *
     * Retrieves a uint32 value representing the enu uint32 ordinal for the case sensitivity of quoted identifiers.
     *
     * The possible values are listed in `arrow.flight.protocol.sql.SqlSupportedCaseSensitivity`.
     *
     * @generated from protobuf enum value: SQL_QUOTED_IDENTIFIER_CASE = 505;
     */
    SQL_QUOTED_IDENTIFIER_CASE = 505,
    /**
     *
     * Retrieves a boolean value indicating whether all tables are selectable.
     *
     * Returns:
     * - false: if not all tables are selectable or if none are;
     * - true: if all tables are selectable.
     *
     * @generated from protobuf enum value: SQL_ALL_TABLES_ARE_SELECTABLE = 506;
     */
    SQL_ALL_TABLES_ARE_SELECTABLE = 506,
    /**
     *
     * Retrieves the null ordering.
     *
     * Returns a uint32 ordinal for the null ordering being used, as described in
     * `arrow.flight.protocol.sql.SqlNullOrdering`.
     *
     * @generated from protobuf enum value: SQL_NULL_ORDERING = 507;
     */
    SQL_NULL_ORDERING = 507,
    /**
     * Retrieves a UTF-8 string list with values of the supported keywords.
     *
     * @generated from protobuf enum value: SQL_KEYWORDS = 508;
     */
    SQL_KEYWORDS = 508,
    /**
     * Retrieves a UTF-8 string list with values of the supported numeric functions.
     *
     * @generated from protobuf enum value: SQL_NUMERIC_FUNCTIONS = 509;
     */
    SQL_NUMERIC_FUNCTIONS = 509,
    /**
     * Retrieves a UTF-8 string list with values of the supported string functions.
     *
     * @generated from protobuf enum value: SQL_STRING_FUNCTIONS = 510;
     */
    SQL_STRING_FUNCTIONS = 510,
    /**
     * Retrieves a UTF-8 string list with values of the supported system functions.
     *
     * @generated from protobuf enum value: SQL_SYSTEM_FUNCTIONS = 511;
     */
    SQL_SYSTEM_FUNCTIONS = 511,
    /**
     * Retrieves a UTF-8 string list with values of the supported datetime functions.
     *
     * @generated from protobuf enum value: SQL_DATETIME_FUNCTIONS = 512;
     */
    SQL_DATETIME_FUNCTIONS = 512,
    /**
     *
     * Retrieves the UTF-8 string that can be used to escape wildcard characters.
     * This is the string that can be used to escape '_' or '%' in the catalog search parameters that are a pattern
     * (and therefore use one of the wildcard characters).
     * The '_' character represents any single character; the '%' character represents any sequence of zero or more
     * characters.
     *
     * @generated from protobuf enum value: SQL_SEARCH_STRING_ESCAPE = 513;
     */
    SQL_SEARCH_STRING_ESCAPE = 513,
    /**
     *
     * Retrieves a UTF-8 string with all the "extra" characters that can be used in unquoted identifier names
     * (those beyond a-z, A-Z, 0-9 and _).
     *
     * @generated from protobuf enum value: SQL_EXTRA_NAME_CHARACTERS = 514;
     */
    SQL_EXTRA_NAME_CHARACTERS = 514,
    /**
     *
     * Retrieves a boolean value indicating whether column aliasing is supported.
     * If so, the SQL AS clause can be used to provide names for computed columns or to provide alias names for columns
     * as required.
     *
     * Returns:
     * - false: if column aliasing is unsupported;
     * - true: if column aliasing is supported.
     *
     * @generated from protobuf enum value: SQL_SUPPORTS_COLUMN_ALIASING = 515;
     */
    SQL_SUPPORTS_COLUMN_ALIASING = 515,
    /**
     *
     * Retrieves a boolean value indicating whether concatenations between null and non-null values being
     * null are supported.
     *
     * - Returns:
     * - false: if concatenations between null and non-null values being null are unsupported;
     * - true: if concatenations between null and non-null values being null are supported.
     *
     * @generated from protobuf enum value: SQL_NULL_PLUS_NULL_IS_NULL = 516;
     */
    SQL_NULL_PLUS_NULL_IS_NULL = 516,
    /**
     *
     * Retrieves a map where the key is the type to convert from and the value is a list with the types to convert to,
     * indicating the supported conversions. Each key and each item on the list value is a value to a predefined type on
     * SqlSupportsConvert enum.
     * The returned map will be:  map<int32, list<int32>>
     *
     * @generated from protobuf enum value: SQL_SUPPORTS_CONVERT = 517;
     */
    SQL_SUPPORTS_CONVERT = 517,
    /**
     *
     * Retrieves a boolean value indicating whether, when table correlation names are supported,
     * they are restricted to being different from the names of the tables.
     *
     * Returns:
     * - false: if table correlation names are unsupported;
     * - true: if table correlation names are supported.
     *
     * @generated from protobuf enum value: SQL_SUPPORTS_TABLE_CORRELATION_NAMES = 518;
     */
    SQL_SUPPORTS_TABLE_CORRELATION_NAMES = 518,
    /**
     *
     * Retrieves a boolean value indicating whether, when table correlation names are supported,
     * they are restricted to being different from the names of the tables.
     *
     * Returns:
     * - false: if different table correlation names are unsupported;
     * - true: if different table correlation names are supported
     *
     * @generated from protobuf enum value: SQL_SUPPORTS_DIFFERENT_TABLE_CORRELATION_NAMES = 519;
     */
    SQL_SUPPORTS_DIFFERENT_TABLE_CORRELATION_NAMES = 519,
    /**
     *
     * Retrieves a boolean value indicating whether expressions in ORDER BY lists are supported.
     *
     * Returns:
     * - false: if expressions in ORDER BY are unsupported;
     * - true: if expressions in ORDER BY are supported;
     *
     * @generated from protobuf enum value: SQL_SUPPORTS_EXPRESSIONS_IN_ORDER_BY = 520;
     */
    SQL_SUPPORTS_EXPRESSIONS_IN_ORDER_BY = 520,
    /**
     *
     * Retrieves a boolean value indicating whether using a column that is not in the SELECT statement in a GROUP BY
     * clause is supported.
     *
     * Returns:
     * - false: if using a column that is not in the SELECT statement in a GROUP BY clause is unsupported;
     * - true: if using a column that is not in the SELECT statement in a GROUP BY clause is supported.
     *
     * @generated from protobuf enum value: SQL_SUPPORTS_ORDER_BY_UNRELATED = 521;
     */
    SQL_SUPPORTS_ORDER_BY_UNRELATED = 521,
    /**
     *
     * Retrieves the supported GROUP BY commands;
     *
     * Returns an int32 bitmask value representing the supported commands.
     * The returned bitmask should be parsed in order to retrieve the supported commands.
     *
     * For instance:
     * - return 0 (\b0)   => [] (GROUP BY is unsupported);
     * - return 1 (\b1)   => [SQL_GROUP_BY_UNRELATED];
     * - return 2 (\b10)  => [SQL_GROUP_BY_BEYOND_SELECT];
     * - return 3 (\b11)  => [SQL_GROUP_BY_UNRELATED, SQL_GROUP_BY_BEYOND_SELECT].
     * Valid GROUP BY types are described under `arrow.flight.protocol.sql.SqlSupportedGroupBy`.
     *
     * @generated from protobuf enum value: SQL_SUPPORTED_GROUP_BY = 522;
     */
    SQL_SUPPORTED_GROUP_BY = 522,
    /**
     *
     * Retrieves a boolean value indicating whether specifying a LIKE escape clause is supported.
     *
     * Returns:
     * - false: if specifying a LIKE escape clause is unsupported;
     * - true: if specifying a LIKE escape clause is supported.
     *
     * @generated from protobuf enum value: SQL_SUPPORTS_LIKE_ESCAPE_CLAUSE = 523;
     */
    SQL_SUPPORTS_LIKE_ESCAPE_CLAUSE = 523,
    /**
     *
     * Retrieves a boolean value indicating whether columns may be defined as non-nullable.
     *
     * Returns:
     * - false: if columns cannot be defined as non-nullable;
     * - true: if columns may be defined as non-nullable.
     *
     * @generated from protobuf enum value: SQL_SUPPORTS_NON_NULLABLE_COLUMNS = 524;
     */
    SQL_SUPPORTS_NON_NULLABLE_COLUMNS = 524,
    /**
     *
     * Retrieves the supported SQL grammar level as per the ODBC specification.
     *
     * Returns an int32 bitmask value representing the supported SQL grammar level.
     * The returned bitmask should be parsed in order to retrieve the supported grammar levels.
     *
     * For instance:
     * - return 0 (\b0)   => [] (SQL grammar is unsupported);
     * - return 1 (\b1)   => [SQL_MINIMUM_GRAMMAR];
     * - return 2 (\b10)  => [SQL_CORE_GRAMMAR];
     * - return 3 (\b11)  => [SQL_MINIMUM_GRAMMAR, SQL_CORE_GRAMMAR];
     * - return 4 (\b100) => [SQL_EXTENDED_GRAMMAR];
     * - return 5 (\b101) => [SQL_MINIMUM_GRAMMAR, SQL_EXTENDED_GRAMMAR];
     * - return 6 (\b110) => [SQL_CORE_GRAMMAR, SQL_EXTENDED_GRAMMAR];
     * - return 7 (\b111) => [SQL_MINIMUM_GRAMMAR, SQL_CORE_GRAMMAR, SQL_EXTENDED_GRAMMAR].
     * Valid SQL grammar levels are described under `arrow.flight.protocol.sql.SupportedSqlGrammar`.
     *
     * @generated from protobuf enum value: SQL_SUPPORTED_GRAMMAR = 525;
     */
    SQL_SUPPORTED_GRAMMAR = 525,
    /**
     *
     * Retrieves the supported ANSI92 SQL grammar level.
     *
     * Returns an int32 bitmask value representing the supported ANSI92 SQL grammar level.
     * The returned bitmask should be parsed in order to retrieve the supported commands.
     *
     * For instance:
     * - return 0 (\b0)   => [] (ANSI92 SQL grammar is unsupported);
     * - return 1 (\b1)   => [ANSI92_ENTRY_SQL];
     * - return 2 (\b10)  => [ANSI92_INTERMEDIATE_SQL];
     * - return 3 (\b11)  => [ANSI92_ENTRY_SQL, ANSI92_INTERMEDIATE_SQL];
     * - return 4 (\b100) => [ANSI92_FULL_SQL];
     * - return 5 (\b101) => [ANSI92_ENTRY_SQL, ANSI92_FULL_SQL];
     * - return 6 (\b110) => [ANSI92_INTERMEDIATE_SQL, ANSI92_FULL_SQL];
     * - return 7 (\b111) => [ANSI92_ENTRY_SQL, ANSI92_INTERMEDIATE_SQL, ANSI92_FULL_SQL].
     * Valid ANSI92 SQL grammar levels are described under `arrow.flight.protocol.sql.SupportedAnsi92SqlGrammarLevel`.
     *
     * @generated from protobuf enum value: SQL_ANSI92_SUPPORTED_LEVEL = 526;
     */
    SQL_ANSI92_SUPPORTED_LEVEL = 526,
    /**
     *
     * Retrieves a boolean value indicating whether the SQL Integrity Enhancement Facility is supported.
     *
     * Returns:
     * - false: if the SQL Integrity Enhancement Facility is supported;
     * - true: if the SQL Integrity Enhancement Facility is supported.
     *
     * @generated from protobuf enum value: SQL_SUPPORTS_INTEGRITY_ENHANCEMENT_FACILITY = 527;
     */
    SQL_SUPPORTS_INTEGRITY_ENHANCEMENT_FACILITY = 527,
    /**
     *
     * Retrieves the support level for SQL OUTER JOINs.
     *
     * Returns a uint3 uint32 ordinal for the SQL ordering being used, as described in
     * `arrow.flight.protocol.sql.SqlOuterJoinsSupportLevel`.
     *
     * @generated from protobuf enum value: SQL_OUTER_JOINS_SUPPORT_LEVEL = 528;
     */
    SQL_OUTER_JOINS_SUPPORT_LEVEL = 528,
    /**
     * Retrieves a UTF-8 string with the preferred term for "schema".
     *
     * @generated from protobuf enum value: SQL_SCHEMA_TERM = 529;
     */
    SQL_SCHEMA_TERM = 529,
    /**
     * Retrieves a UTF-8 string with the preferred term for "procedure".
     *
     * @generated from protobuf enum value: SQL_PROCEDURE_TERM = 530;
     */
    SQL_PROCEDURE_TERM = 530,
    /**
     * Retrieves a UTF-8 string with the preferred term for "catalog".
     *
     * @generated from protobuf enum value: SQL_CATALOG_TERM = 531;
     */
    SQL_CATALOG_TERM = 531,
    /**
     *
     * Retrieves a boolean value indicating whether a catalog appears at the start of a fully qualified table name.
     *
     * - false: if a catalog does not appear at the start of a fully qualified table name;
     * - true: if a catalog appears at the start of a fully qualified table name.
     *
     * @generated from protobuf enum value: SQL_CATALOG_AT_START = 532;
     */
    SQL_CATALOG_AT_START = 532,
    /**
     *
     * Retrieves the supported actions for a SQL schema.
     *
     * Returns an int32 bitmask value representing the supported actions for a SQL schema.
     * The returned bitmask should be parsed in order to retrieve the supported actions for a SQL schema.
     *
     * For instance:
     * - return 0 (\b0)   => [] (no supported actions for SQL schema);
     * - return 1 (\b1)   => [SQL_ELEMENT_IN_PROCEDURE_CALLS];
     * - return 2 (\b10)  => [SQL_ELEMENT_IN_INDEX_DEFINITIONS];
     * - return 3 (\b11)  => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS];
     * - return 4 (\b100) => [SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
     * - return 5 (\b101) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
     * - return 6 (\b110) => [SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
     * - return 7 (\b111) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS].
     * Valid actions for a SQL schema described under `arrow.flight.protocol.sql.SqlSupportedElementActions`.
     *
     * @generated from protobuf enum value: SQL_SCHEMAS_SUPPORTED_ACTIONS = 533;
     */
    SQL_SCHEMAS_SUPPORTED_ACTIONS = 533,
    /**
     *
     * Retrieves the supported actions for a SQL schema.
     *
     * Returns an int32 bitmask value representing the supported actions for a SQL catalog.
     * The returned bitmask should be parsed in order to retrieve the supported actions for a SQL catalog.
     *
     * For instance:
     * - return 0 (\b0)   => [] (no supported actions for SQL catalog);
     * - return 1 (\b1)   => [SQL_ELEMENT_IN_PROCEDURE_CALLS];
     * - return 2 (\b10)  => [SQL_ELEMENT_IN_INDEX_DEFINITIONS];
     * - return 3 (\b11)  => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS];
     * - return 4 (\b100) => [SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
     * - return 5 (\b101) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
     * - return 6 (\b110) => [SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
     * - return 7 (\b111) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS].
     * Valid actions for a SQL catalog are described under `arrow.flight.protocol.sql.SqlSupportedElementActions`.
     *
     * @generated from protobuf enum value: SQL_CATALOGS_SUPPORTED_ACTIONS = 534;
     */
    SQL_CATALOGS_SUPPORTED_ACTIONS = 534,
    /**
     *
     * Retrieves the supported SQL positioned commands.
     *
     * Returns an int32 bitmask value representing the supported SQL positioned commands.
     * The returned bitmask should be parsed in order to retrieve the supported SQL positioned commands.
     *
     * For instance:
     * - return 0 (\b0)   => [] (no supported SQL positioned commands);
     * - return 1 (\b1)   => [SQL_POSITIONED_DELETE];
     * - return 2 (\b10)  => [SQL_POSITIONED_UPDATE];
     * - return 3 (\b11)  => [SQL_POSITIONED_DELETE, SQL_POSITIONED_UPDATE].
     * Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlSupportedPositionedCommands`.
     *
     * @generated from protobuf enum value: SQL_SUPPORTED_POSITIONED_COMMANDS = 535;
     */
    SQL_SUPPORTED_POSITIONED_COMMANDS = 535,
    /**
     *
     * Retrieves a boolean value indicating whether SELECT FOR UPDATE statements are supported.
     *
     * Returns:
     * - false: if SELECT FOR UPDATE statements are unsupported;
     * - true: if SELECT FOR UPDATE statements are supported.
     *
     * @generated from protobuf enum value: SQL_SELECT_FOR_UPDATE_SUPPORTED = 536;
     */
    SQL_SELECT_FOR_UPDATE_SUPPORTED = 536,
    /**
     *
     * Retrieves a boolean value indicating whether stored procedure calls that use the stored procedure escape syntax
     * are supported.
     *
     * Returns:
     * - false: if stored procedure calls that use the stored procedure escape syntax are unsupported;
     * - true: if stored procedure calls that use the stored procedure escape syntax are supported.
     *
     * @generated from protobuf enum value: SQL_STORED_PROCEDURES_SUPPORTED = 537;
     */
    SQL_STORED_PROCEDURES_SUPPORTED = 537,
    /**
     *
     * Retrieves the supported SQL subqueries.
     *
     * Returns an int32 bitmask value representing the supported SQL subqueries.
     * The returned bitmask should be parsed in order to retrieve the supported SQL subqueries.
     *
     * For instance:
     * - return 0   (\b0)     => [] (no supported SQL subqueries);
     * - return 1   (\b1)     => [SQL_SUBQUERIES_IN_COMPARISONS];
     * - return 2   (\b10)    => [SQL_SUBQUERIES_IN_EXISTS];
     * - return 3   (\b11)    => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS];
     * - return 4   (\b100)   => [SQL_SUBQUERIES_IN_INS];
     * - return 5   (\b101)   => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_INS];
     * - return 6   (\b110)   => [SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_EXISTS];
     * - return 7   (\b111)   => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS];
     * - return 8   (\b1000)  => [SQL_SUBQUERIES_IN_QUANTIFIEDS];
     * - return 9   (\b1001)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
     * - return 10  (\b1010)  => [SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
     * - return 11  (\b1011)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
     * - return 12  (\b1100)  => [SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
     * - return 13  (\b1101)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
     * - return 14  (\b1110)  => [SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
     * - return 15  (\b1111)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
     * - ...
     * Valid SQL subqueries are described under `arrow.flight.protocol.sql.SqlSupportedSubqueries`.
     *
     * @generated from protobuf enum value: SQL_SUPPORTED_SUBQUERIES = 538;
     */
    SQL_SUPPORTED_SUBQUERIES = 538,
    /**
     *
     * Retrieves a boolean value indicating whether correlated subqueries are supported.
     *
     * Returns:
     * - false: if correlated subqueries are unsupported;
     * - true: if correlated subqueries are supported.
     *
     * @generated from protobuf enum value: SQL_CORRELATED_SUBQUERIES_SUPPORTED = 539;
     */
    SQL_CORRELATED_SUBQUERIES_SUPPORTED = 539,
    /**
     *
     * Retrieves the supported SQL UNIONs.
     *
     * Returns an int32 bitmask value representing the supported SQL UNIONs.
     * The returned bitmask should be parsed in order to retrieve the supported SQL UNIONs.
     *
     * For instance:
     * - return 0 (\b0)   => [] (no supported SQL positioned commands);
     * - return 1 (\b1)   => [SQL_UNION];
     * - return 2 (\b10)  => [SQL_UNION_ALL];
     * - return 3 (\b11)  => [SQL_UNION, SQL_UNION_ALL].
     * Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlSupportedUnions`.
     *
     * @generated from protobuf enum value: SQL_SUPPORTED_UNIONS = 540;
     */
    SQL_SUPPORTED_UNIONS = 540,
    /**
     * Retrieves a uint32 value representing the maximum number of hex characters allowed in an inline binary literal.
     *
     * @generated from protobuf enum value: SQL_MAX_BINARY_LITERAL_LENGTH = 541;
     */
    SQL_MAX_BINARY_LITERAL_LENGTH = 541,
    /**
     * Retrieves a uint32 value representing the maximum number of characters allowed for a character literal.
     *
     * @generated from protobuf enum value: SQL_MAX_CHAR_LITERAL_LENGTH = 542;
     */
    SQL_MAX_CHAR_LITERAL_LENGTH = 542,
    /**
     * Retrieves a uint32 value representing the maximum number of characters allowed for a column name.
     *
     * @generated from protobuf enum value: SQL_MAX_COLUMN_NAME_LENGTH = 543;
     */
    SQL_MAX_COLUMN_NAME_LENGTH = 543,
    /**
     * Retrieves a uint32 value representing the the maximum number of columns allowed in a GROUP BY clause.
     *
     * @generated from protobuf enum value: SQL_MAX_COLUMNS_IN_GROUP_BY = 544;
     */
    SQL_MAX_COLUMNS_IN_GROUP_BY = 544,
    /**
     * Retrieves a uint32 value representing the maximum number of columns allowed in an index.
     *
     * @generated from protobuf enum value: SQL_MAX_COLUMNS_IN_INDEX = 545;
     */
    SQL_MAX_COLUMNS_IN_INDEX = 545,
    /**
     * Retrieves a uint32 value representing the maximum number of columns allowed in an ORDER BY clause.
     *
     * @generated from protobuf enum value: SQL_MAX_COLUMNS_IN_ORDER_BY = 546;
     */
    SQL_MAX_COLUMNS_IN_ORDER_BY = 546,
    /**
     * Retrieves a uint32 value representing the maximum number of columns allowed in a SELECT list.
     *
     * @generated from protobuf enum value: SQL_MAX_COLUMNS_IN_SELECT = 547;
     */
    SQL_MAX_COLUMNS_IN_SELECT = 547,
    /**
     * Retrieves a uint32 value representing the maximum number of columns allowed in a table.
     *
     * @generated from protobuf enum value: SQL_MAX_COLUMNS_IN_TABLE = 548;
     */
    SQL_MAX_COLUMNS_IN_TABLE = 548,
    /**
     * Retrieves a uint32 value representing the maximum number of concurrent connections possible.
     *
     * @generated from protobuf enum value: SQL_MAX_CONNECTIONS = 549;
     */
    SQL_MAX_CONNECTIONS = 549,
    /**
     * Retrieves a uint32 value the maximum number of characters allowed in a cursor name.
     *
     * @generated from protobuf enum value: SQL_MAX_CURSOR_NAME_LENGTH = 550;
     */
    SQL_MAX_CURSOR_NAME_LENGTH = 550,
    /**
     *
     * Retrieves a uint32 value representing the maximum number of bytes allowed for an index,
     * including all of the parts of the index.
     *
     * @generated from protobuf enum value: SQL_MAX_INDEX_LENGTH = 551;
     */
    SQL_MAX_INDEX_LENGTH = 551,
    /**
     * Retrieves a uint32 value representing the maximum number of characters allowed in a schema name.
     *
     * @generated from protobuf enum value: SQL_DB_SCHEMA_NAME_LENGTH = 552;
     */
    SQL_DB_SCHEMA_NAME_LENGTH = 552,
    /**
     * Retrieves a uint32 value representing the maximum number of characters allowed in a procedure name.
     *
     * @generated from protobuf enum value: SQL_MAX_PROCEDURE_NAME_LENGTH = 553;
     */
    SQL_MAX_PROCEDURE_NAME_LENGTH = 553,
    /**
     * Retrieves a uint32 value representing the maximum number of characters allowed in a catalog name.
     *
     * @generated from protobuf enum value: SQL_MAX_CATALOG_NAME_LENGTH = 554;
     */
    SQL_MAX_CATALOG_NAME_LENGTH = 554,
    /**
     * Retrieves a uint32 value representing the maximum number of bytes allowed in a single row.
     *
     * @generated from protobuf enum value: SQL_MAX_ROW_SIZE = 555;
     */
    SQL_MAX_ROW_SIZE = 555,
    /**
     *
     * Retrieves a boolean indicating whether the return value for the JDBC method getMaxRowSize includes the SQL
     * data types LONGVARCHAR and LONGVARBINARY.
     *
     * Returns:
     * - false: if return value for the JDBC method getMaxRowSize does
     *          not include the SQL data types LONGVARCHAR and LONGVARBINARY;
     * - true: if return value for the JDBC method getMaxRowSize includes
     *         the SQL data types LONGVARCHAR and LONGVARBINARY.
     *
     * @generated from protobuf enum value: SQL_MAX_ROW_SIZE_INCLUDES_BLOBS = 556;
     */
    SQL_MAX_ROW_SIZE_INCLUDES_BLOBS = 556,
    /**
     *
     * Retrieves a uint32 value representing the maximum number of characters allowed for an SQL statement;
     * a result of 0 (zero) means that there is no limit or the limit is not known.
     *
     * @generated from protobuf enum value: SQL_MAX_STATEMENT_LENGTH = 557;
     */
    SQL_MAX_STATEMENT_LENGTH = 557,
    /**
     * Retrieves a uint32 value representing the maximum number of active statements that can be open at the same time.
     *
     * @generated from protobuf enum value: SQL_MAX_STATEMENTS = 558;
     */
    SQL_MAX_STATEMENTS = 558,
    /**
     * Retrieves a uint32 value representing the maximum number of characters allowed in a table name.
     *
     * @generated from protobuf enum value: SQL_MAX_TABLE_NAME_LENGTH = 559;
     */
    SQL_MAX_TABLE_NAME_LENGTH = 559,
    /**
     * Retrieves a uint32 value representing the maximum number of tables allowed in a SELECT statement.
     *
     * @generated from protobuf enum value: SQL_MAX_TABLES_IN_SELECT = 560;
     */
    SQL_MAX_TABLES_IN_SELECT = 560,
    /**
     * Retrieves a uint32 value representing the maximum number of characters allowed in a user name.
     *
     * @generated from protobuf enum value: SQL_MAX_USERNAME_LENGTH = 561;
     */
    SQL_MAX_USERNAME_LENGTH = 561,
    /**
     *
     * Retrieves this database's default transaction isolation level as described in
     * `arrow.flight.protocol.sql.SqlTransactionIsolationLevel`.
     *
     * Returns a uint32 ordinal for the SQL transaction isolation level.
     *
     * @generated from protobuf enum value: SQL_DEFAULT_TRANSACTION_ISOLATION = 562;
     */
    SQL_DEFAULT_TRANSACTION_ISOLATION = 562,
    /**
     *
     * Retrieves a boolean value indicating whether transactions are supported. If not, invoking the method commit is a
     * noop, and the isolation level is `arrow.flight.protocol.sql.SqlTransactionIsolationLevel.TRANSACTION_NONE`.
     *
     * Returns:
     * - false: if transactions are unsupported;
     * - true: if transactions are supported.
     *
     * @generated from protobuf enum value: SQL_TRANSACTIONS_SUPPORTED = 563;
     */
    SQL_TRANSACTIONS_SUPPORTED = 563,
    /**
     *
     * Retrieves the supported transactions isolation levels.
     *
     * Returns an int32 bitmask value representing the supported transactions isolation levels.
     * The returned bitmask should be parsed in order to retrieve the supported transactions isolation levels.
     *
     * For instance:
     * - return 0   (\b0)     => [] (no supported SQL transactions isolation levels);
     * - return 1   (\b1)     => [SQL_TRANSACTION_NONE];
     * - return 2   (\b10)    => [SQL_TRANSACTION_READ_UNCOMMITTED];
     * - return 3   (\b11)    => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED];
     * - return 4   (\b100)   => [SQL_TRANSACTION_REPEATABLE_READ];
     * - return 5   (\b101)   => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 6   (\b110)   => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 7   (\b111)   => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 8   (\b1000)  => [SQL_TRANSACTION_REPEATABLE_READ];
     * - return 9   (\b1001)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 10  (\b1010)  => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 11  (\b1011)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 12  (\b1100)  => [SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 13  (\b1101)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 14  (\b1110)  => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 15  (\b1111)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
     * - return 16  (\b10000) => [SQL_TRANSACTION_SERIALIZABLE];
     * - ...
     * Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlTransactionIsolationLevel`.
     *
     * @generated from protobuf enum value: SQL_SUPPORTED_TRANSACTIONS_ISOLATION_LEVELS = 564;
     */
    SQL_SUPPORTED_TRANSACTIONS_ISOLATION_LEVELS = 564,
    /**
     *
     * Retrieves a boolean value indicating whether a data definition statement within a transaction forces
     * the transaction to commit.
     *
     * Returns:
     * - false: if a data definition statement within a transaction does not force the transaction to commit;
     * - true: if a data definition statement within a transaction forces the transaction to commit.
     *
     * @generated from protobuf enum value: SQL_DATA_DEFINITION_CAUSES_TRANSACTION_COMMIT = 565;
     */
    SQL_DATA_DEFINITION_CAUSES_TRANSACTION_COMMIT = 565,
    /**
     *
     * Retrieves a boolean value indicating whether a data definition statement within a transaction is ignored.
     *
     * Returns:
     * - false: if a data definition statement within a transaction is taken into account;
     * - true: a data definition statement within a transaction is ignored.
     *
     * @generated from protobuf enum value: SQL_DATA_DEFINITIONS_IN_TRANSACTIONS_IGNORED = 566;
     */
    SQL_DATA_DEFINITIONS_IN_TRANSACTIONS_IGNORED = 566,
    /**
     *
     * Retrieves an int32 bitmask value representing the supported result set types.
     * The returned bitmask should be parsed in order to retrieve the supported result set types.
     *
     * For instance:
     * - return 0   (\b0)     => [] (no supported result set types);
     * - return 1   (\b1)     => [SQL_RESULT_SET_TYPE_UNSPECIFIED];
     * - return 2   (\b10)    => [SQL_RESULT_SET_TYPE_FORWARD_ONLY];
     * - return 3   (\b11)    => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_FORWARD_ONLY];
     * - return 4   (\b100)   => [SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
     * - return 5   (\b101)   => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
     * - return 6   (\b110)   => [SQL_RESULT_SET_TYPE_FORWARD_ONLY, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
     * - return 7   (\b111)   => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_FORWARD_ONLY, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
     * - return 8   (\b1000)  => [SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE];
     * - ...
     * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetType`.
     *
     * @generated from protobuf enum value: SQL_SUPPORTED_RESULT_SET_TYPES = 567;
     */
    SQL_SUPPORTED_RESULT_SET_TYPES = 567,
    /**
     *
     * Returns an int32 bitmask value concurrency types supported for
     * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_UNSPECIFIED`.
     *
     * For instance:
     * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
     * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
     * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
     * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
     * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
     *
     * @generated from protobuf enum value: SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_UNSPECIFIED = 568;
     */
    SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_UNSPECIFIED = 568,
    /**
     *
     * Returns an int32 bitmask value concurrency types supported for
     * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_FORWARD_ONLY`.
     *
     * For instance:
     * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
     * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
     * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
     * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
     * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
     *
     * @generated from protobuf enum value: SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_FORWARD_ONLY = 569;
     */
    SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_FORWARD_ONLY = 569,
    /**
     *
     * Returns an int32 bitmask value concurrency types supported for
     * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE`.
     *
     * For instance:
     * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
     * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
     * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
     * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
     * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
     *
     * @generated from protobuf enum value: SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_SENSITIVE = 570;
     */
    SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_SENSITIVE = 570,
    /**
     *
     * Returns an int32 bitmask value concurrency types supported for
     * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE`.
     *
     * For instance:
     * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
     * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
     * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
     * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
     * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
     * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
     *
     * @generated from protobuf enum value: SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_INSENSITIVE = 571;
     */
    SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_INSENSITIVE = 571,
    /**
     *
     * Retrieves a boolean value indicating whether this database supports batch updates.
     *
     * - false: if this database does not support batch updates;
     * - true: if this database supports batch updates.
     *
     * @generated from protobuf enum value: SQL_BATCH_UPDATES_SUPPORTED = 572;
     */
    SQL_BATCH_UPDATES_SUPPORTED = 572,
    /**
     *
     * Retrieves a boolean value indicating whether this database supports savepoints.
     *
     * Returns:
     * - false: if this database does not support savepoints;
     * - true: if this database supports savepoints.
     *
     * @generated from protobuf enum value: SQL_SAVEPOINTS_SUPPORTED = 573;
     */
    SQL_SAVEPOINTS_SUPPORTED = 573,
    /**
     *
     * Retrieves a boolean value indicating whether named parameters are supported in callable statements.
     *
     * Returns:
     * - false: if named parameters in callable statements are unsupported;
     * - true: if named parameters in callable statements are supported.
     *
     * @generated from protobuf enum value: SQL_NAMED_PARAMETERS_SUPPORTED = 574;
     */
    SQL_NAMED_PARAMETERS_SUPPORTED = 574,
    /**
     *
     * Retrieves a boolean value indicating whether updates made to a LOB are made on a copy or directly to the LOB.
     *
     * Returns:
     * - false: if updates made to a LOB are made directly to the LOB;
     * - true: if updates made to a LOB are made on a copy.
     *
     * @generated from protobuf enum value: SQL_LOCATORS_UPDATE_COPY = 575;
     */
    SQL_LOCATORS_UPDATE_COPY = 575,
    /**
     *
     * Retrieves a boolean value indicating whether invoking user-defined or vendor functions
     * using the stored procedure escape syntax is supported.
     *
     * Returns:
     * - false: if invoking user-defined or vendor functions using the stored procedure escape syntax is unsupported;
     * - true: if invoking user-defined or vendor functions using the stored procedure escape syntax is supported.
     *
     * @generated from protobuf enum value: SQL_STORED_FUNCTIONS_USING_CALL_SYNTAX_SUPPORTED = 576;
     */
    SQL_STORED_FUNCTIONS_USING_CALL_SYNTAX_SUPPORTED = 576
}
/**
 * @generated from protobuf enum arrow.flight.protocol.sql.SqlSupportedCaseSensitivity
 */
export enum SqlSupportedCaseSensitivity {
    /**
     * @generated from protobuf enum value: SQL_CASE_SENSITIVITY_UNKNOWN = 0;
     */
    SQL_CASE_SENSITIVITY_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: SQL_CASE_SENSITIVITY_CASE_INSENSITIVE = 1;
     */
    SQL_CASE_SENSITIVITY_CASE_INSENSITIVE = 1,
    /**
     * @generated from protobuf enum value: SQL_CASE_SENSITIVITY_UPPERCASE = 2;
     */
    SQL_CASE_SENSITIVITY_UPPERCASE = 2,
    /**
     * @generated from protobuf enum value: SQL_CASE_SENSITIVITY_LOWERCASE = 3;
     */
    SQL_CASE_SENSITIVITY_LOWERCASE = 3
}
/**
 * @generated from protobuf enum arrow.flight.protocol.sql.SqlNullOrdering
 */
export enum SqlNullOrdering {
    /**
     * @generated from protobuf enum value: SQL_NULLS_SORTED_HIGH = 0;
     */
    SQL_NULLS_SORTED_HIGH = 0,
    /**
     * @generated from protobuf enum value: SQL_NULLS_SORTED_LOW = 1;
     */
    SQL_NULLS_SORTED_LOW = 1,
    /**
     * @generated from protobuf enum value: SQL_NULLS_SORTED_AT_START = 2;
     */
    SQL_NULLS_SORTED_AT_START = 2,
    /**
     * @generated from protobuf enum value: SQL_NULLS_SORTED_AT_END = 3;
     */
    SQL_NULLS_SORTED_AT_END = 3
}
/**
 * @generated from protobuf enum arrow.flight.protocol.sql.SupportedSqlGrammar
 */
export enum SupportedSqlGrammar {
    /**
     * @generated from protobuf enum value: SQL_MINIMUM_GRAMMAR = 0;
     */
    SQL_MINIMUM_GRAMMAR = 0,
    /**
     * @generated from protobuf enum value: SQL_CORE_GRAMMAR = 1;
     */
    SQL_CORE_GRAMMAR = 1,
    /**
     * @generated from protobuf enum value: SQL_EXTENDED_GRAMMAR = 2;
     */
    SQL_EXTENDED_GRAMMAR = 2
}
/**
 * @generated from protobuf enum arrow.flight.protocol.sql.SupportedAnsi92SqlGrammarLevel
 */
export enum SupportedAnsi92SqlGrammarLevel {
    /**
     * @generated from protobuf enum value: ANSI92_ENTRY_SQL = 0;
     */
    ANSI92_ENTRY_SQL = 0,
    /**
     * @generated from protobuf enum value: ANSI92_INTERMEDIATE_SQL = 1;
     */
    ANSI92_INTERMEDIATE_SQL = 1,
    /**
     * @generated from protobuf enum value: ANSI92_FULL_SQL = 2;
     */
    ANSI92_FULL_SQL = 2
}
/**
 * @generated from protobuf enum arrow.flight.protocol.sql.SqlOuterJoinsSupportLevel
 */
export enum SqlOuterJoinsSupportLevel {
    /**
     * @generated from protobuf enum value: SQL_JOINS_UNSUPPORTED = 0;
     */
    SQL_JOINS_UNSUPPORTED = 0,
    /**
     * @generated from protobuf enum value: SQL_LIMITED_OUTER_JOINS = 1;
     */
    SQL_LIMITED_OUTER_JOINS = 1,
    /**
     * @generated from protobuf enum value: SQL_FULL_OUTER_JOINS = 2;
     */
    SQL_FULL_OUTER_JOINS = 2
}
/**
 * @generated from protobuf enum arrow.flight.protocol.sql.SqlSupportedGroupBy
 */
export enum SqlSupportedGroupBy {
    /**
     * @generated from protobuf enum value: SQL_GROUP_BY_UNRELATED = 0;
     */
    SQL_GROUP_BY_UNRELATED = 0,
    /**
     * @generated from protobuf enum value: SQL_GROUP_BY_BEYOND_SELECT = 1;
     */
    SQL_GROUP_BY_BEYOND_SELECT = 1
}
/**
 * @generated from protobuf enum arrow.flight.protocol.sql.SqlSupportedElementActions
 */
export enum SqlSupportedElementActions {
    /**
     * @generated from protobuf enum value: SQL_ELEMENT_IN_PROCEDURE_CALLS = 0;
     */
    SQL_ELEMENT_IN_PROCEDURE_CALLS = 0,
    /**
     * @generated from protobuf enum value: SQL_ELEMENT_IN_INDEX_DEFINITIONS = 1;
     */
    SQL_ELEMENT_IN_INDEX_DEFINITIONS = 1,
    /**
     * @generated from protobuf enum value: SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS = 2;
     */
    SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS = 2
}
/**
 * @generated from protobuf enum arrow.flight.protocol.sql.SqlSupportedPositionedCommands
 */
export enum SqlSupportedPositionedCommands {
    /**
     * @generated from protobuf enum value: SQL_POSITIONED_DELETE = 0;
     */
    SQL_POSITIONED_DELETE = 0,
    /**
     * @generated from protobuf enum value: SQL_POSITIONED_UPDATE = 1;
     */
    SQL_POSITIONED_UPDATE = 1
}
/**
 * @generated from protobuf enum arrow.flight.protocol.sql.SqlSupportedSubqueries
 */
export enum SqlSupportedSubqueries {
    /**
     * @generated from protobuf enum value: SQL_SUBQUERIES_IN_COMPARISONS = 0;
     */
    SQL_SUBQUERIES_IN_COMPARISONS = 0,
    /**
     * @generated from protobuf enum value: SQL_SUBQUERIES_IN_EXISTS = 1;
     */
    SQL_SUBQUERIES_IN_EXISTS = 1,
    /**
     * @generated from protobuf enum value: SQL_SUBQUERIES_IN_INS = 2;
     */
    SQL_SUBQUERIES_IN_INS = 2,
    /**
     * @generated from protobuf enum value: SQL_SUBQUERIES_IN_QUANTIFIEDS = 3;
     */
    SQL_SUBQUERIES_IN_QUANTIFIEDS = 3
}
/**
 * @generated from protobuf enum arrow.flight.protocol.sql.SqlSupportedUnions
 */
export enum SqlSupportedUnions {
    /**
     * @generated from protobuf enum value: SQL_UNION = 0;
     */
    SQL_UNION = 0,
    /**
     * @generated from protobuf enum value: SQL_UNION_ALL = 1;
     */
    SQL_UNION_ALL = 1
}
/**
 * @generated from protobuf enum arrow.flight.protocol.sql.SqlTransactionIsolationLevel
 */
export enum SqlTransactionIsolationLevel {
    /**
     * @generated from protobuf enum value: SQL_TRANSACTION_NONE = 0;
     */
    SQL_TRANSACTION_NONE = 0,
    /**
     * @generated from protobuf enum value: SQL_TRANSACTION_READ_UNCOMMITTED = 1;
     */
    SQL_TRANSACTION_READ_UNCOMMITTED = 1,
    /**
     * @generated from protobuf enum value: SQL_TRANSACTION_READ_COMMITTED = 2;
     */
    SQL_TRANSACTION_READ_COMMITTED = 2,
    /**
     * @generated from protobuf enum value: SQL_TRANSACTION_REPEATABLE_READ = 3;
     */
    SQL_TRANSACTION_REPEATABLE_READ = 3,
    /**
     * @generated from protobuf enum value: SQL_TRANSACTION_SERIALIZABLE = 4;
     */
    SQL_TRANSACTION_SERIALIZABLE = 4
}
/**
 * @generated from protobuf enum arrow.flight.protocol.sql.SqlSupportedTransactions
 */
export enum SqlSupportedTransactions {
    /**
     * @generated from protobuf enum value: SQL_TRANSACTION_UNSPECIFIED = 0;
     */
    SQL_TRANSACTION_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SQL_DATA_DEFINITION_TRANSACTIONS = 1;
     */
    SQL_DATA_DEFINITION_TRANSACTIONS = 1,
    /**
     * @generated from protobuf enum value: SQL_DATA_MANIPULATION_TRANSACTIONS = 2;
     */
    SQL_DATA_MANIPULATION_TRANSACTIONS = 2
}
/**
 * @generated from protobuf enum arrow.flight.protocol.sql.SqlSupportedResultSetType
 */
export enum SqlSupportedResultSetType {
    /**
     * @generated from protobuf enum value: SQL_RESULT_SET_TYPE_UNSPECIFIED = 0;
     */
    SQL_RESULT_SET_TYPE_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SQL_RESULT_SET_TYPE_FORWARD_ONLY = 1;
     */
    SQL_RESULT_SET_TYPE_FORWARD_ONLY = 1,
    /**
     * @generated from protobuf enum value: SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE = 2;
     */
    SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE = 2,
    /**
     * @generated from protobuf enum value: SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE = 3;
     */
    SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE = 3
}
/**
 * @generated from protobuf enum arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency
 */
export enum SqlSupportedResultSetConcurrency {
    /**
     * @generated from protobuf enum value: SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED = 0;
     */
    SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SQL_RESULT_SET_CONCURRENCY_READ_ONLY = 1;
     */
    SQL_RESULT_SET_CONCURRENCY_READ_ONLY = 1,
    /**
     * @generated from protobuf enum value: SQL_RESULT_SET_CONCURRENCY_UPDATABLE = 2;
     */
    SQL_RESULT_SET_CONCURRENCY_UPDATABLE = 2
}
/**
 * @generated from protobuf enum arrow.flight.protocol.sql.SqlSupportsConvert
 */
export enum SqlSupportsConvert {
    /**
     * @generated from protobuf enum value: SQL_CONVERT_BIGINT = 0;
     */
    SQL_CONVERT_BIGINT = 0,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_BINARY = 1;
     */
    SQL_CONVERT_BINARY = 1,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_BIT = 2;
     */
    SQL_CONVERT_BIT = 2,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_CHAR = 3;
     */
    SQL_CONVERT_CHAR = 3,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_DATE = 4;
     */
    SQL_CONVERT_DATE = 4,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_DECIMAL = 5;
     */
    SQL_CONVERT_DECIMAL = 5,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_FLOAT = 6;
     */
    SQL_CONVERT_FLOAT = 6,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_INTEGER = 7;
     */
    SQL_CONVERT_INTEGER = 7,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_INTERVAL_DAY_TIME = 8;
     */
    SQL_CONVERT_INTERVAL_DAY_TIME = 8,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_INTERVAL_YEAR_MONTH = 9;
     */
    SQL_CONVERT_INTERVAL_YEAR_MONTH = 9,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_LONGVARBINARY = 10;
     */
    SQL_CONVERT_LONGVARBINARY = 10,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_LONGVARCHAR = 11;
     */
    SQL_CONVERT_LONGVARCHAR = 11,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_NUMERIC = 12;
     */
    SQL_CONVERT_NUMERIC = 12,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_REAL = 13;
     */
    SQL_CONVERT_REAL = 13,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_SMALLINT = 14;
     */
    SQL_CONVERT_SMALLINT = 14,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_TIME = 15;
     */
    SQL_CONVERT_TIME = 15,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_TIMESTAMP = 16;
     */
    SQL_CONVERT_TIMESTAMP = 16,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_TINYINT = 17;
     */
    SQL_CONVERT_TINYINT = 17,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_VARBINARY = 18;
     */
    SQL_CONVERT_VARBINARY = 18,
    /**
     * @generated from protobuf enum value: SQL_CONVERT_VARCHAR = 19;
     */
    SQL_CONVERT_VARCHAR = 19
}
/**
 * @generated from protobuf enum arrow.flight.protocol.sql.UpdateDeleteRules
 */
export enum UpdateDeleteRules {
    /**
     * @generated from protobuf enum value: CASCADE = 0;
     */
    CASCADE = 0,
    /**
     * @generated from protobuf enum value: RESTRICT = 1;
     */
    RESTRICT = 1,
    /**
     * @generated from protobuf enum value: SET_NULL = 2;
     */
    SET_NULL = 2,
    /**
     * @generated from protobuf enum value: NO_ACTION = 3;
     */
    NO_ACTION = 3,
    /**
     * @generated from protobuf enum value: SET_DEFAULT = 4;
     */
    SET_DEFAULT = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class CommandGetSqlInfo$Type extends MessageType<CommandGetSqlInfo> {
    constructor() {
        super("arrow.flight.protocol.sql.CommandGetSqlInfo", [
            { no: 1, name: "info", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<CommandGetSqlInfo>): CommandGetSqlInfo {
        const message = { info: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CommandGetSqlInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandGetSqlInfo): CommandGetSqlInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 info */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.info.push(reader.uint32());
                    else
                        message.info.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandGetSqlInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 info = 1; */
        if (message.info.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.info.length; i++)
                writer.uint32(message.info[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.CommandGetSqlInfo
 */
export const CommandGetSqlInfo = new CommandGetSqlInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandGetCatalogs$Type extends MessageType<CommandGetCatalogs> {
    constructor() {
        super("arrow.flight.protocol.sql.CommandGetCatalogs", [], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<CommandGetCatalogs>): CommandGetCatalogs {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CommandGetCatalogs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandGetCatalogs): CommandGetCatalogs {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CommandGetCatalogs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.CommandGetCatalogs
 */
export const CommandGetCatalogs = new CommandGetCatalogs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandGetDbSchemas$Type extends MessageType<CommandGetDbSchemas> {
    constructor() {
        super("arrow.flight.protocol.sql.CommandGetDbSchemas", [
            { no: 1, name: "catalog", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "db_schema_filter_pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<CommandGetDbSchemas>): CommandGetDbSchemas {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CommandGetDbSchemas>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandGetDbSchemas): CommandGetDbSchemas {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string catalog */ 1:
                    message.catalog = reader.string();
                    break;
                case /* optional string db_schema_filter_pattern */ 2:
                    message.dbSchemaFilterPattern = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandGetDbSchemas, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string catalog = 1; */
        if (message.catalog !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.catalog);
        /* optional string db_schema_filter_pattern = 2; */
        if (message.dbSchemaFilterPattern !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.dbSchemaFilterPattern);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.CommandGetDbSchemas
 */
export const CommandGetDbSchemas = new CommandGetDbSchemas$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandGetTables$Type extends MessageType<CommandGetTables> {
    constructor() {
        super("arrow.flight.protocol.sql.CommandGetTables", [
            { no: 1, name: "catalog", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "db_schema_filter_pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "table_name_filter_pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "table_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "include_schema", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<CommandGetTables>): CommandGetTables {
        const message = { tableTypes: [], includeSchema: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CommandGetTables>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandGetTables): CommandGetTables {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string catalog */ 1:
                    message.catalog = reader.string();
                    break;
                case /* optional string db_schema_filter_pattern */ 2:
                    message.dbSchemaFilterPattern = reader.string();
                    break;
                case /* optional string table_name_filter_pattern */ 3:
                    message.tableNameFilterPattern = reader.string();
                    break;
                case /* repeated string table_types */ 4:
                    message.tableTypes.push(reader.string());
                    break;
                case /* bool include_schema */ 5:
                    message.includeSchema = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandGetTables, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string catalog = 1; */
        if (message.catalog !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.catalog);
        /* optional string db_schema_filter_pattern = 2; */
        if (message.dbSchemaFilterPattern !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.dbSchemaFilterPattern);
        /* optional string table_name_filter_pattern = 3; */
        if (message.tableNameFilterPattern !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tableNameFilterPattern);
        /* repeated string table_types = 4; */
        for (let i = 0; i < message.tableTypes.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.tableTypes[i]);
        /* bool include_schema = 5; */
        if (message.includeSchema !== false)
            writer.tag(5, WireType.Varint).bool(message.includeSchema);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.CommandGetTables
 */
export const CommandGetTables = new CommandGetTables$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandGetTableTypes$Type extends MessageType<CommandGetTableTypes> {
    constructor() {
        super("arrow.flight.protocol.sql.CommandGetTableTypes", [], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<CommandGetTableTypes>): CommandGetTableTypes {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CommandGetTableTypes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandGetTableTypes): CommandGetTableTypes {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CommandGetTableTypes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.CommandGetTableTypes
 */
export const CommandGetTableTypes = new CommandGetTableTypes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandGetPrimaryKeys$Type extends MessageType<CommandGetPrimaryKeys> {
    constructor() {
        super("arrow.flight.protocol.sql.CommandGetPrimaryKeys", [
            { no: 1, name: "catalog", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "db_schema", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "table", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<CommandGetPrimaryKeys>): CommandGetPrimaryKeys {
        const message = { table: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CommandGetPrimaryKeys>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandGetPrimaryKeys): CommandGetPrimaryKeys {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string catalog */ 1:
                    message.catalog = reader.string();
                    break;
                case /* optional string db_schema */ 2:
                    message.dbSchema = reader.string();
                    break;
                case /* string table */ 3:
                    message.table = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandGetPrimaryKeys, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string catalog = 1; */
        if (message.catalog !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.catalog);
        /* optional string db_schema = 2; */
        if (message.dbSchema !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.dbSchema);
        /* string table = 3; */
        if (message.table !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.table);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.CommandGetPrimaryKeys
 */
export const CommandGetPrimaryKeys = new CommandGetPrimaryKeys$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandGetExportedKeys$Type extends MessageType<CommandGetExportedKeys> {
    constructor() {
        super("arrow.flight.protocol.sql.CommandGetExportedKeys", [
            { no: 1, name: "catalog", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "db_schema", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "table", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<CommandGetExportedKeys>): CommandGetExportedKeys {
        const message = { table: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CommandGetExportedKeys>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandGetExportedKeys): CommandGetExportedKeys {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string catalog */ 1:
                    message.catalog = reader.string();
                    break;
                case /* optional string db_schema */ 2:
                    message.dbSchema = reader.string();
                    break;
                case /* string table */ 3:
                    message.table = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandGetExportedKeys, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string catalog = 1; */
        if (message.catalog !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.catalog);
        /* optional string db_schema = 2; */
        if (message.dbSchema !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.dbSchema);
        /* string table = 3; */
        if (message.table !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.table);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.CommandGetExportedKeys
 */
export const CommandGetExportedKeys = new CommandGetExportedKeys$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandGetImportedKeys$Type extends MessageType<CommandGetImportedKeys> {
    constructor() {
        super("arrow.flight.protocol.sql.CommandGetImportedKeys", [
            { no: 1, name: "catalog", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "db_schema", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "table", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<CommandGetImportedKeys>): CommandGetImportedKeys {
        const message = { table: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CommandGetImportedKeys>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandGetImportedKeys): CommandGetImportedKeys {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string catalog */ 1:
                    message.catalog = reader.string();
                    break;
                case /* optional string db_schema */ 2:
                    message.dbSchema = reader.string();
                    break;
                case /* string table */ 3:
                    message.table = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandGetImportedKeys, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string catalog = 1; */
        if (message.catalog !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.catalog);
        /* optional string db_schema = 2; */
        if (message.dbSchema !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.dbSchema);
        /* string table = 3; */
        if (message.table !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.table);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.CommandGetImportedKeys
 */
export const CommandGetImportedKeys = new CommandGetImportedKeys$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandGetCrossReference$Type extends MessageType<CommandGetCrossReference> {
    constructor() {
        super("arrow.flight.protocol.sql.CommandGetCrossReference", [
            { no: 1, name: "pk_catalog", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pk_db_schema", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pk_table", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "fk_catalog", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "fk_db_schema", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "fk_table", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<CommandGetCrossReference>): CommandGetCrossReference {
        const message = { pkTable: "", fkTable: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CommandGetCrossReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandGetCrossReference): CommandGetCrossReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string pk_catalog */ 1:
                    message.pkCatalog = reader.string();
                    break;
                case /* optional string pk_db_schema */ 2:
                    message.pkDbSchema = reader.string();
                    break;
                case /* string pk_table */ 3:
                    message.pkTable = reader.string();
                    break;
                case /* optional string fk_catalog */ 4:
                    message.fkCatalog = reader.string();
                    break;
                case /* optional string fk_db_schema */ 5:
                    message.fkDbSchema = reader.string();
                    break;
                case /* string fk_table */ 6:
                    message.fkTable = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandGetCrossReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string pk_catalog = 1; */
        if (message.pkCatalog !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.pkCatalog);
        /* optional string pk_db_schema = 2; */
        if (message.pkDbSchema !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.pkDbSchema);
        /* string pk_table = 3; */
        if (message.pkTable !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.pkTable);
        /* optional string fk_catalog = 4; */
        if (message.fkCatalog !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.fkCatalog);
        /* optional string fk_db_schema = 5; */
        if (message.fkDbSchema !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.fkDbSchema);
        /* string fk_table = 6; */
        if (message.fkTable !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.fkTable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.CommandGetCrossReference
 */
export const CommandGetCrossReference = new CommandGetCrossReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActionCreatePreparedStatementRequest$Type extends MessageType<ActionCreatePreparedStatementRequest> {
    constructor() {
        super("arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest", [
            { no: 1, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<ActionCreatePreparedStatementRequest>): ActionCreatePreparedStatementRequest {
        const message = { query: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActionCreatePreparedStatementRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActionCreatePreparedStatementRequest): ActionCreatePreparedStatementRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string query */ 1:
                    message.query = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActionCreatePreparedStatementRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string query = 1; */
        if (message.query !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.query);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest
 */
export const ActionCreatePreparedStatementRequest = new ActionCreatePreparedStatementRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActionCreatePreparedStatementResult$Type extends MessageType<ActionCreatePreparedStatementResult> {
    constructor() {
        super("arrow.flight.protocol.sql.ActionCreatePreparedStatementResult", [
            { no: 1, name: "prepared_statement_handle", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "dataset_schema", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "parameter_schema", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<ActionCreatePreparedStatementResult>): ActionCreatePreparedStatementResult {
        const message = { preparedStatementHandle: new Uint8Array(0), datasetSchema: new Uint8Array(0), parameterSchema: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActionCreatePreparedStatementResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActionCreatePreparedStatementResult): ActionCreatePreparedStatementResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes prepared_statement_handle */ 1:
                    message.preparedStatementHandle = reader.bytes();
                    break;
                case /* bytes dataset_schema */ 2:
                    message.datasetSchema = reader.bytes();
                    break;
                case /* bytes parameter_schema */ 3:
                    message.parameterSchema = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActionCreatePreparedStatementResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes prepared_statement_handle = 1; */
        if (message.preparedStatementHandle.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.preparedStatementHandle);
        /* bytes dataset_schema = 2; */
        if (message.datasetSchema.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.datasetSchema);
        /* bytes parameter_schema = 3; */
        if (message.parameterSchema.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.parameterSchema);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.ActionCreatePreparedStatementResult
 */
export const ActionCreatePreparedStatementResult = new ActionCreatePreparedStatementResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActionClosePreparedStatementRequest$Type extends MessageType<ActionClosePreparedStatementRequest> {
    constructor() {
        super("arrow.flight.protocol.sql.ActionClosePreparedStatementRequest", [
            { no: 1, name: "prepared_statement_handle", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<ActionClosePreparedStatementRequest>): ActionClosePreparedStatementRequest {
        const message = { preparedStatementHandle: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActionClosePreparedStatementRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActionClosePreparedStatementRequest): ActionClosePreparedStatementRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes prepared_statement_handle */ 1:
                    message.preparedStatementHandle = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActionClosePreparedStatementRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes prepared_statement_handle = 1; */
        if (message.preparedStatementHandle.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.preparedStatementHandle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.ActionClosePreparedStatementRequest
 */
export const ActionClosePreparedStatementRequest = new ActionClosePreparedStatementRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandStatementQuery$Type extends MessageType<CommandStatementQuery> {
    constructor() {
        super("arrow.flight.protocol.sql.CommandStatementQuery", [
            { no: 1, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<CommandStatementQuery>): CommandStatementQuery {
        const message = { query: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CommandStatementQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandStatementQuery): CommandStatementQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string query */ 1:
                    message.query = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandStatementQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string query = 1; */
        if (message.query !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.query);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.CommandStatementQuery
 */
export const CommandStatementQuery = new CommandStatementQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TicketStatementQuery$Type extends MessageType<TicketStatementQuery> {
    constructor() {
        super("arrow.flight.protocol.sql.TicketStatementQuery", [
            { no: 1, name: "statement_handle", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<TicketStatementQuery>): TicketStatementQuery {
        const message = { statementHandle: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TicketStatementQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TicketStatementQuery): TicketStatementQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes statement_handle */ 1:
                    message.statementHandle = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TicketStatementQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes statement_handle = 1; */
        if (message.statementHandle.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.statementHandle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.TicketStatementQuery
 */
export const TicketStatementQuery = new TicketStatementQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandPreparedStatementQuery$Type extends MessageType<CommandPreparedStatementQuery> {
    constructor() {
        super("arrow.flight.protocol.sql.CommandPreparedStatementQuery", [
            { no: 1, name: "prepared_statement_handle", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<CommandPreparedStatementQuery>): CommandPreparedStatementQuery {
        const message = { preparedStatementHandle: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CommandPreparedStatementQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandPreparedStatementQuery): CommandPreparedStatementQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes prepared_statement_handle */ 1:
                    message.preparedStatementHandle = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandPreparedStatementQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes prepared_statement_handle = 1; */
        if (message.preparedStatementHandle.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.preparedStatementHandle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.CommandPreparedStatementQuery
 */
export const CommandPreparedStatementQuery = new CommandPreparedStatementQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandStatementUpdate$Type extends MessageType<CommandStatementUpdate> {
    constructor() {
        super("arrow.flight.protocol.sql.CommandStatementUpdate", [
            { no: 1, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<CommandStatementUpdate>): CommandStatementUpdate {
        const message = { query: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CommandStatementUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandStatementUpdate): CommandStatementUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string query */ 1:
                    message.query = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandStatementUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string query = 1; */
        if (message.query !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.query);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.CommandStatementUpdate
 */
export const CommandStatementUpdate = new CommandStatementUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandPreparedStatementUpdate$Type extends MessageType<CommandPreparedStatementUpdate> {
    constructor() {
        super("arrow.flight.protocol.sql.CommandPreparedStatementUpdate", [
            { no: 1, name: "prepared_statement_handle", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<CommandPreparedStatementUpdate>): CommandPreparedStatementUpdate {
        const message = { preparedStatementHandle: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CommandPreparedStatementUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandPreparedStatementUpdate): CommandPreparedStatementUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes prepared_statement_handle */ 1:
                    message.preparedStatementHandle = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandPreparedStatementUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes prepared_statement_handle = 1; */
        if (message.preparedStatementHandle.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.preparedStatementHandle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.CommandPreparedStatementUpdate
 */
export const CommandPreparedStatementUpdate = new CommandPreparedStatementUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DoPutUpdateResult$Type extends MessageType<DoPutUpdateResult> {
    constructor() {
        super("arrow.flight.protocol.sql.DoPutUpdateResult", [
            { no: 1, name: "record_count", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ], { "arrow.flight.protocol.sql.experimental": true });
    }
    create(value?: PartialMessage<DoPutUpdateResult>): DoPutUpdateResult {
        const message = { recordCount: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DoPutUpdateResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DoPutUpdateResult): DoPutUpdateResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 record_count */ 1:
                    message.recordCount = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DoPutUpdateResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 record_count = 1; */
        if (message.recordCount !== 0n)
            writer.tag(1, WireType.Varint).int64(message.recordCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.sql.DoPutUpdateResult
 */
export const DoPutUpdateResult = new DoPutUpdateResult$Type();
